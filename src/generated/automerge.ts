// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from "./automerge-ffi";
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from "uniffi-bindgen-react-native";

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== "object" ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== "production" ||
  false;
// Public interface members begin here.

export function root(): ObjId {
  return FfiConverterTypeObjId.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_uniffi_automerge_fn_func_root(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    ),
  );
}

export type Change = {
  actorId: ActorId;
  message: string | undefined;
  deps: Array<ChangeHash>;
  timestamp: /*i64*/ bigint;
  bytes: Array</*u8*/ number>;
  hash: ChangeHash;
};

/**
 * Generated factory for {@link Change} record objects.
 */
export const Change = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Change, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Change}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Change}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link automerge} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Change>,
  });
})();

const FfiConverterTypeChange = (() => {
  type TypeName = Change;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        actorId: FfiConverterTypeActorId.read(from),
        message: FfiConverterOptionalString.read(from),
        deps: FfiConverterArrayTypeChangeHash.read(from),
        timestamp: FfiConverterInt64.read(from),
        bytes: FfiConverterArrayUInt8.read(from),
        hash: FfiConverterTypeChangeHash.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeActorId.write(value.actorId, into);
      FfiConverterOptionalString.write(value.message, into);
      FfiConverterArrayTypeChangeHash.write(value.deps, into);
      FfiConverterInt64.write(value.timestamp, into);
      FfiConverterArrayUInt8.write(value.bytes, into);
      FfiConverterTypeChangeHash.write(value.hash, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeActorId.allocationSize(value.actorId) +
        FfiConverterOptionalString.allocationSize(value.message) +
        FfiConverterArrayTypeChangeHash.allocationSize(value.deps) +
        FfiConverterInt64.allocationSize(value.timestamp) +
        FfiConverterArrayUInt8.allocationSize(value.bytes) +
        FfiConverterTypeChangeHash.allocationSize(value.hash)
      );
    }
  }
  return new FFIConverter();
})();

export type KeyValue = {
  key: string;
  value: Value;
};

/**
 * Generated factory for {@link KeyValue} record objects.
 */
export const KeyValue = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<KeyValue, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link KeyValue}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link KeyValue}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link automerge} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<KeyValue>,
  });
})();

const FfiConverterTypeKeyValue = (() => {
  type TypeName = KeyValue;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        value: FfiConverterTypeValue.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterTypeValue.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterTypeValue.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

export type Mark = {
  start: /*u64*/ bigint;
  end: /*u64*/ bigint;
  name: string;
  value: ScalarValue;
};

/**
 * Generated factory for {@link Mark} record objects.
 */
export const Mark = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Mark, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Mark}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Mark}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link automerge} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Mark>,
  });
})();

const FfiConverterTypeMark = (() => {
  type TypeName = Mark;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        start: FfiConverterUInt64.read(from),
        end: FfiConverterUInt64.read(from),
        name: FfiConverterString.read(from),
        value: FfiConverterTypeScalarValue.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.start, into);
      FfiConverterUInt64.write(value.end, into);
      FfiConverterString.write(value.name, into);
      FfiConverterTypeScalarValue.write(value.value, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.start) +
        FfiConverterUInt64.allocationSize(value.end) +
        FfiConverterString.allocationSize(value.name) +
        FfiConverterTypeScalarValue.allocationSize(value.value)
      );
    }
  }
  return new FFIConverter();
})();

export type Patch = {
  path: Array<PathElement>;
  action: PatchAction;
};

/**
 * Generated factory for {@link Patch} record objects.
 */
export const Patch = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Patch, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Patch}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Patch}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link automerge} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Patch>,
  });
})();

const FfiConverterTypePatch = (() => {
  type TypeName = Patch;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        path: FfiConverterArrayTypePathElement.read(from),
        action: FfiConverterTypePatchAction.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypePathElement.write(value.path, into);
      FfiConverterTypePatchAction.write(value.action, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypePathElement.allocationSize(value.path) +
        FfiConverterTypePatchAction.allocationSize(value.action)
      );
    }
  }
  return new FFIConverter();
})();

export type PathElement = {
  prop: Prop;
  obj: ObjId;
};

/**
 * Generated factory for {@link PathElement} record objects.
 */
export const PathElement = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PathElement, ReturnType<typeof defaults>>(
      defaults,
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PathElement}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PathElement}, with defaults specified
     * in Rust, in the {@link automerge} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link automerge} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PathElement>,
  });
})();

const FfiConverterTypePathElement = (() => {
  type TypeName = PathElement;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        prop: FfiConverterTypeProp.read(from),
        obj: FfiConverterTypeObjId.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeProp.write(value.prop, into);
      FfiConverterTypeObjId.write(value.obj, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeProp.allocationSize(value.prop) +
        FfiConverterTypeObjId.allocationSize(value.obj)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status,
      ),
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status,
      ),
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status,
      ),
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type ActorId = ArrayBuffer;
// FfiConverter for ActorId, a type alias for ArrayBuffer.
const FfiConverterTypeActorId = FfiConverterArrayBuffer;

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type ChangeHash = ArrayBuffer;
// FfiConverter for ChangeHash, a type alias for ArrayBuffer.
const FfiConverterTypeChangeHash = FfiConverterArrayBuffer;

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type Cursor = ArrayBuffer;
// FfiConverter for Cursor, a type alias for ArrayBuffer.
const FfiConverterTypeCursor = FfiConverterArrayBuffer;

/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
export type ObjId = ArrayBuffer;
// FfiConverter for ObjId, a type alias for ArrayBuffer.
const FfiConverterTypeObjId = FfiConverterArrayBuffer;

// Flat error type: DecodeSyncStateError
export enum DecodeSyncStateError_Tags {
  Internal = "Internal",
}
export const DecodeSyncStateError = (() => {
  class Internal extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = "DecodeSyncStateError";
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = DecodeSyncStateError_Tags.Internal;

    constructor(message: string) {
      super("DecodeSyncStateError", "Internal", message);
    }

    static instanceOf(e: any): e is Internal {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is DecodeSyncStateError {
    return (e as any)[uniffiTypeNameSymbol] === "DecodeSyncStateError";
  }
  return {
    Internal,
    instanceOf,
  };
})();

// Union type for DecodeSyncStateError error type.

export type DecodeSyncStateError = InstanceType<
  (typeof DecodeSyncStateError)[keyof Omit<
    typeof DecodeSyncStateError,
    "instanceOf"
  >]
>;

const FfiConverterTypeDecodeSyncStateError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = DecodeSyncStateError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new DecodeSyncStateError.Internal(
            FfiConverterString.read(from),
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Flat error type: DocError
export enum DocError_Tags {
  WrongObjectType = "WrongObjectType",
  Internal = "Internal",
}
export const DocError = (() => {
  class WrongObjectType extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = "DocError";
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = DocError_Tags.WrongObjectType;

    constructor(message: string) {
      super("DocError", "WrongObjectType", message);
    }

    static instanceOf(e: any): e is WrongObjectType {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class Internal extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = "DocError";
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = DocError_Tags.Internal;

    constructor(message: string) {
      super("DocError", "Internal", message);
    }

    static instanceOf(e: any): e is Internal {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is DocError {
    return (e as any)[uniffiTypeNameSymbol] === "DocError";
  }
  return {
    WrongObjectType,
    Internal,
    instanceOf,
  };
})();

// Union type for DocError error type.

export type DocError = InstanceType<
  (typeof DocError)[keyof Omit<typeof DocError, "instanceOf">]
>;

const FfiConverterTypeDocError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = DocError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new DocError.WrongObjectType(FfiConverterString.read(from));

        case 2:
          return new DocError.Internal(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum ExpandMark {
  Before,
  After,
  None,
  Both,
}

const FfiConverterTypeExpandMark = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ExpandMark;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ExpandMark.Before;
        case 2:
          return ExpandMark.After;
        case 3:
          return ExpandMark.None;
        case 4:
          return ExpandMark.Both;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ExpandMark.Before:
          return ordinalConverter.write(1, into);
        case ExpandMark.After:
          return ordinalConverter.write(2, into);
        case ExpandMark.None:
          return ordinalConverter.write(3, into);
        case ExpandMark.Both:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: LoadError
export enum LoadError_Tags {
  Internal = "Internal",
}
export const LoadError = (() => {
  class Internal extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = "LoadError";
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = LoadError_Tags.Internal;

    constructor(message: string) {
      super("LoadError", "Internal", message);
    }

    static instanceOf(e: any): e is Internal {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is LoadError {
    return (e as any)[uniffiTypeNameSymbol] === "LoadError";
  }
  return {
    Internal,
    instanceOf,
  };
})();

// Union type for LoadError error type.

export type LoadError = InstanceType<
  (typeof LoadError)[keyof Omit<typeof LoadError, "instanceOf">]
>;

const FfiConverterTypeLoadError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = LoadError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new LoadError.Internal(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

export enum ObjType {
  Map,
  List,
  Text,
}

const FfiConverterTypeObjType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ObjType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ObjType.Map;
        case 2:
          return ObjType.List;
        case 3:
          return ObjType.Text;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ObjType.Map:
          return ordinalConverter.write(1, into);
        case ObjType.List:
          return ordinalConverter.write(2, into);
        case ObjType.Text:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: PatchAction
export enum PatchAction_Tags {
  Put = "Put",
  Insert = "Insert",
  SpliceText = "SpliceText",
  Increment = "Increment",
  Conflict = "Conflict",
  DeleteMap = "DeleteMap",
  DeleteSeq = "DeleteSeq",
  Marks = "Marks",
}
export const PatchAction = (() => {
  type Put__interface = {
    tag: PatchAction_Tags.Put;
    inner: Readonly<{ obj: ObjId; prop: Prop; value: Value }>;
  };

  class Put_ extends UniffiEnum implements Put__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.Put;
    readonly inner: Readonly<{ obj: ObjId; prop: Prop; value: Value }>;
    constructor(inner: { obj: ObjId; prop: Prop; value: Value }) {
      super("PatchAction", "Put");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { obj: ObjId; prop: Prop; value: Value }): Put_ {
      return new Put_(inner);
    }

    static instanceOf(obj: any): obj is Put_ {
      return obj.tag === PatchAction_Tags.Put;
    }
  }

  type Insert__interface = {
    tag: PatchAction_Tags.Insert;
    inner: Readonly<{
      obj: ObjId;
      index: /*u64*/ bigint;
      values: Array<Value>;
    }>;
  };

  class Insert_ extends UniffiEnum implements Insert__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.Insert;
    readonly inner: Readonly<{
      obj: ObjId;
      index: /*u64*/ bigint;
      values: Array<Value>;
    }>;
    constructor(inner: {
      obj: ObjId;
      index: /*u64*/ bigint;
      values: Array<Value>;
    }) {
      super("PatchAction", "Insert");
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      obj: ObjId;
      index: /*u64*/ bigint;
      values: Array<Value>;
    }): Insert_ {
      return new Insert_(inner);
    }

    static instanceOf(obj: any): obj is Insert_ {
      return obj.tag === PatchAction_Tags.Insert;
    }
  }

  type SpliceText__interface = {
    tag: PatchAction_Tags.SpliceText;
    inner: Readonly<{
      obj: ObjId;
      index: /*u64*/ bigint;
      value: string;
      marks: Map<string, Value>;
    }>;
  };

  class SpliceText_ extends UniffiEnum implements SpliceText__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.SpliceText;
    readonly inner: Readonly<{
      obj: ObjId;
      index: /*u64*/ bigint;
      value: string;
      marks: Map<string, Value>;
    }>;
    constructor(inner: {
      obj: ObjId;
      index: /*u64*/ bigint;
      value: string;
      marks: Map<string, Value>;
    }) {
      super("PatchAction", "SpliceText");
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      obj: ObjId;
      index: /*u64*/ bigint;
      value: string;
      marks: Map<string, Value>;
    }): SpliceText_ {
      return new SpliceText_(inner);
    }

    static instanceOf(obj: any): obj is SpliceText_ {
      return obj.tag === PatchAction_Tags.SpliceText;
    }
  }

  type Increment__interface = {
    tag: PatchAction_Tags.Increment;
    inner: Readonly<{ obj: ObjId; prop: Prop; value: /*i64*/ bigint }>;
  };

  class Increment_ extends UniffiEnum implements Increment__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.Increment;
    readonly inner: Readonly<{ obj: ObjId; prop: Prop; value: /*i64*/ bigint }>;
    constructor(inner: { obj: ObjId; prop: Prop; value: /*i64*/ bigint }) {
      super("PatchAction", "Increment");
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      obj: ObjId;
      prop: Prop;
      value: /*i64*/ bigint;
    }): Increment_ {
      return new Increment_(inner);
    }

    static instanceOf(obj: any): obj is Increment_ {
      return obj.tag === PatchAction_Tags.Increment;
    }
  }

  type Conflict__interface = {
    tag: PatchAction_Tags.Conflict;
    inner: Readonly<{ obj: ObjId; prop: Prop }>;
  };

  class Conflict_ extends UniffiEnum implements Conflict__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.Conflict;
    readonly inner: Readonly<{ obj: ObjId; prop: Prop }>;
    constructor(inner: { obj: ObjId; prop: Prop }) {
      super("PatchAction", "Conflict");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { obj: ObjId; prop: Prop }): Conflict_ {
      return new Conflict_(inner);
    }

    static instanceOf(obj: any): obj is Conflict_ {
      return obj.tag === PatchAction_Tags.Conflict;
    }
  }

  type DeleteMap__interface = {
    tag: PatchAction_Tags.DeleteMap;
    inner: Readonly<{ obj: ObjId; key: string }>;
  };

  class DeleteMap_ extends UniffiEnum implements DeleteMap__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.DeleteMap;
    readonly inner: Readonly<{ obj: ObjId; key: string }>;
    constructor(inner: { obj: ObjId; key: string }) {
      super("PatchAction", "DeleteMap");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { obj: ObjId; key: string }): DeleteMap_ {
      return new DeleteMap_(inner);
    }

    static instanceOf(obj: any): obj is DeleteMap_ {
      return obj.tag === PatchAction_Tags.DeleteMap;
    }
  }

  type DeleteSeq__interface = {
    tag: PatchAction_Tags.DeleteSeq;
    inner: Readonly<{
      obj: ObjId;
      index: /*u64*/ bigint;
      length: /*u64*/ bigint;
    }>;
  };

  class DeleteSeq_ extends UniffiEnum implements DeleteSeq__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.DeleteSeq;
    readonly inner: Readonly<{
      obj: ObjId;
      index: /*u64*/ bigint;
      length: /*u64*/ bigint;
    }>;
    constructor(inner: {
      obj: ObjId;
      index: /*u64*/ bigint;
      length: /*u64*/ bigint;
    }) {
      super("PatchAction", "DeleteSeq");
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      obj: ObjId;
      index: /*u64*/ bigint;
      length: /*u64*/ bigint;
    }): DeleteSeq_ {
      return new DeleteSeq_(inner);
    }

    static instanceOf(obj: any): obj is DeleteSeq_ {
      return obj.tag === PatchAction_Tags.DeleteSeq;
    }
  }

  type Marks__interface = {
    tag: PatchAction_Tags.Marks;
    inner: Readonly<{ obj: ObjId; marks: Array<Mark> }>;
  };

  class Marks_ extends UniffiEnum implements Marks__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "PatchAction";
    readonly tag = PatchAction_Tags.Marks;
    readonly inner: Readonly<{ obj: ObjId; marks: Array<Mark> }>;
    constructor(inner: { obj: ObjId; marks: Array<Mark> }) {
      super("PatchAction", "Marks");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { obj: ObjId; marks: Array<Mark> }): Marks_ {
      return new Marks_(inner);
    }

    static instanceOf(obj: any): obj is Marks_ {
      return obj.tag === PatchAction_Tags.Marks;
    }
  }

  function instanceOf(obj: any): obj is PatchAction {
    return obj[uniffiTypeNameSymbol] === "PatchAction";
  }

  return Object.freeze({
    instanceOf,
    Put: Put_,
    Insert: Insert_,
    SpliceText: SpliceText_,
    Increment: Increment_,
    Conflict: Conflict_,
    DeleteMap: DeleteMap_,
    DeleteSeq: DeleteSeq_,
    Marks: Marks_,
  });
})();

export type PatchAction = InstanceType<
  (typeof PatchAction)[keyof Omit<typeof PatchAction, "instanceOf">]
>;

// FfiConverter for enum PatchAction
const FfiConverterTypePatchAction = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = PatchAction;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new PatchAction.Put({
            obj: FfiConverterTypeObjId.read(from),
            prop: FfiConverterTypeProp.read(from),
            value: FfiConverterTypeValue.read(from),
          });
        case 2:
          return new PatchAction.Insert({
            obj: FfiConverterTypeObjId.read(from),
            index: FfiConverterUInt64.read(from),
            values: FfiConverterArrayTypeValue.read(from),
          });
        case 3:
          return new PatchAction.SpliceText({
            obj: FfiConverterTypeObjId.read(from),
            index: FfiConverterUInt64.read(from),
            value: FfiConverterString.read(from),
            marks: FfiConverterMapStringTypeValue.read(from),
          });
        case 4:
          return new PatchAction.Increment({
            obj: FfiConverterTypeObjId.read(from),
            prop: FfiConverterTypeProp.read(from),
            value: FfiConverterInt64.read(from),
          });
        case 5:
          return new PatchAction.Conflict({
            obj: FfiConverterTypeObjId.read(from),
            prop: FfiConverterTypeProp.read(from),
          });
        case 6:
          return new PatchAction.DeleteMap({
            obj: FfiConverterTypeObjId.read(from),
            key: FfiConverterString.read(from),
          });
        case 7:
          return new PatchAction.DeleteSeq({
            obj: FfiConverterTypeObjId.read(from),
            index: FfiConverterUInt64.read(from),
            length: FfiConverterUInt64.read(from),
          });
        case 8:
          return new PatchAction.Marks({
            obj: FfiConverterTypeObjId.read(from),
            marks: FfiConverterArrayTypeMark.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case PatchAction_Tags.Put: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterTypeProp.write(inner.prop, into);
          FfiConverterTypeValue.write(inner.value, into);
          return;
        }
        case PatchAction_Tags.Insert: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterUInt64.write(inner.index, into);
          FfiConverterArrayTypeValue.write(inner.values, into);
          return;
        }
        case PatchAction_Tags.SpliceText: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterUInt64.write(inner.index, into);
          FfiConverterString.write(inner.value, into);
          FfiConverterMapStringTypeValue.write(inner.marks, into);
          return;
        }
        case PatchAction_Tags.Increment: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterTypeProp.write(inner.prop, into);
          FfiConverterInt64.write(inner.value, into);
          return;
        }
        case PatchAction_Tags.Conflict: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterTypeProp.write(inner.prop, into);
          return;
        }
        case PatchAction_Tags.DeleteMap: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterString.write(inner.key, into);
          return;
        }
        case PatchAction_Tags.DeleteSeq: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterUInt64.write(inner.index, into);
          FfiConverterUInt64.write(inner.length, into);
          return;
        }
        case PatchAction_Tags.Marks: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterTypeObjId.write(inner.obj, into);
          FfiConverterArrayTypeMark.write(inner.marks, into);
          return;
        }
        default:
          // Throwing from here means that PatchAction_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case PatchAction_Tags.Put: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterTypeProp.allocationSize(inner.prop);
          size += FfiConverterTypeValue.allocationSize(inner.value);
          return size;
        }
        case PatchAction_Tags.Insert: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterUInt64.allocationSize(inner.index);
          size += FfiConverterArrayTypeValue.allocationSize(inner.values);
          return size;
        }
        case PatchAction_Tags.SpliceText: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterUInt64.allocationSize(inner.index);
          size += FfiConverterString.allocationSize(inner.value);
          size += FfiConverterMapStringTypeValue.allocationSize(inner.marks);
          return size;
        }
        case PatchAction_Tags.Increment: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterTypeProp.allocationSize(inner.prop);
          size += FfiConverterInt64.allocationSize(inner.value);
          return size;
        }
        case PatchAction_Tags.Conflict: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterTypeProp.allocationSize(inner.prop);
          return size;
        }
        case PatchAction_Tags.DeleteMap: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterString.allocationSize(inner.key);
          return size;
        }
        case PatchAction_Tags.DeleteSeq: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterUInt64.allocationSize(inner.index);
          size += FfiConverterUInt64.allocationSize(inner.length);
          return size;
        }
        case PatchAction_Tags.Marks: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterTypeObjId.allocationSize(inner.obj);
          size += FfiConverterArrayTypeMark.allocationSize(inner.marks);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Position
export enum Position_Tags {
  Cursor = "Cursor",
  Index = "Index",
}
export const Position = (() => {
  type Cursor__interface = {
    tag: Position_Tags.Cursor;
    inner: Readonly<{ position: Cursor }>;
  };

  class Cursor_ extends UniffiEnum implements Cursor__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "Position";
    readonly tag = Position_Tags.Cursor;
    readonly inner: Readonly<{ position: Cursor }>;
    constructor(inner: { position: Cursor }) {
      super("Position", "Cursor");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { position: Cursor }): Cursor_ {
      return new Cursor_(inner);
    }

    static instanceOf(obj: any): obj is Cursor_ {
      return obj.tag === Position_Tags.Cursor;
    }
  }

  type Index__interface = {
    tag: Position_Tags.Index;
    inner: Readonly<{ position: /*u64*/ bigint }>;
  };

  class Index_ extends UniffiEnum implements Index__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "Position";
    readonly tag = Position_Tags.Index;
    readonly inner: Readonly<{ position: /*u64*/ bigint }>;
    constructor(inner: { position: /*u64*/ bigint }) {
      super("Position", "Index");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { position: /*u64*/ bigint }): Index_ {
      return new Index_(inner);
    }

    static instanceOf(obj: any): obj is Index_ {
      return obj.tag === Position_Tags.Index;
    }
  }

  function instanceOf(obj: any): obj is Position {
    return obj[uniffiTypeNameSymbol] === "Position";
  }

  return Object.freeze({
    instanceOf,
    Cursor: Cursor_,
    Index: Index_,
  });
})();

export type Position = InstanceType<
  (typeof Position)[keyof Omit<typeof Position, "instanceOf">]
>;

// FfiConverter for enum Position
const FfiConverterTypePosition = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Position;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Position.Cursor({
            position: FfiConverterTypeCursor.read(from),
          });
        case 2:
          return new Position.Index({
            position: FfiConverterUInt64.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Position_Tags.Cursor: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeCursor.write(inner.position, into);
          return;
        }
        case Position_Tags.Index: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.position, into);
          return;
        }
        default:
          // Throwing from here means that Position_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Position_Tags.Cursor: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeCursor.allocationSize(inner.position);
          return size;
        }
        case Position_Tags.Index: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.position);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Prop
export enum Prop_Tags {
  Key = "Key",
  Index = "Index",
}
export const Prop = (() => {
  type Key__interface = {
    tag: Prop_Tags.Key;
    inner: Readonly<{ value: string }>;
  };

  class Key_ extends UniffiEnum implements Key__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "Prop";
    readonly tag = Prop_Tags.Key;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super("Prop", "Key");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): Key_ {
      return new Key_(inner);
    }

    static instanceOf(obj: any): obj is Key_ {
      return obj.tag === Prop_Tags.Key;
    }
  }

  type Index__interface = {
    tag: Prop_Tags.Index;
    inner: Readonly<{ value: /*u64*/ bigint }>;
  };

  class Index_ extends UniffiEnum implements Index__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "Prop";
    readonly tag = Prop_Tags.Index;
    readonly inner: Readonly<{ value: /*u64*/ bigint }>;
    constructor(inner: { value: /*u64*/ bigint }) {
      super("Prop", "Index");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*u64*/ bigint }): Index_ {
      return new Index_(inner);
    }

    static instanceOf(obj: any): obj is Index_ {
      return obj.tag === Prop_Tags.Index;
    }
  }

  function instanceOf(obj: any): obj is Prop {
    return obj[uniffiTypeNameSymbol] === "Prop";
  }

  return Object.freeze({
    instanceOf,
    Key: Key_,
    Index: Index_,
  });
})();

export type Prop = InstanceType<
  (typeof Prop)[keyof Omit<typeof Prop, "instanceOf">]
>;

// FfiConverter for enum Prop
const FfiConverterTypeProp = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Prop;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Prop.Key({ value: FfiConverterString.read(from) });
        case 2:
          return new Prop.Index({ value: FfiConverterUInt64.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Prop_Tags.Key: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        case Prop_Tags.Index: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that Prop_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Prop_Tags.Key: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        case Prop_Tags.Index: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: ReceiveSyncError
export enum ReceiveSyncError_Tags {
  Internal = "Internal",
  InvalidMessage = "InvalidMessage",
}
export const ReceiveSyncError = (() => {
  class Internal extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = "ReceiveSyncError";
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = ReceiveSyncError_Tags.Internal;

    constructor(message: string) {
      super("ReceiveSyncError", "Internal", message);
    }

    static instanceOf(e: any): e is Internal {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class InvalidMessage extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = "ReceiveSyncError";
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = ReceiveSyncError_Tags.InvalidMessage;

    constructor(message: string) {
      super("ReceiveSyncError", "InvalidMessage", message);
    }

    static instanceOf(e: any): e is InvalidMessage {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is ReceiveSyncError {
    return (e as any)[uniffiTypeNameSymbol] === "ReceiveSyncError";
  }
  return {
    Internal,
    InvalidMessage,
    instanceOf,
  };
})();

// Union type for ReceiveSyncError error type.

export type ReceiveSyncError = InstanceType<
  (typeof ReceiveSyncError)[keyof Omit<typeof ReceiveSyncError, "instanceOf">]
>;

const FfiConverterTypeReceiveSyncError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = ReceiveSyncError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ReceiveSyncError.Internal(FfiConverterString.read(from));

        case 2:
          return new ReceiveSyncError.InvalidMessage(
            FfiConverterString.read(from),
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: ScalarValue
export enum ScalarValue_Tags {
  Bytes = "Bytes",
  String = "String",
  Uint = "Uint",
  Int = "Int",
  F64 = "F64",
  Counter = "Counter",
  Timestamp = "Timestamp",
  Boolean = "Boolean",
  Unknown = "Unknown",
  Null = "Null",
}
export const ScalarValue = (() => {
  type Bytes__interface = {
    tag: ScalarValue_Tags.Bytes;
    inner: Readonly<{ value: Array</*u8*/ number> }>;
  };

  class Bytes_ extends UniffiEnum implements Bytes__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Bytes;
    readonly inner: Readonly<{ value: Array</*u8*/ number> }>;
    constructor(inner: { value: Array</*u8*/ number> }) {
      super("ScalarValue", "Bytes");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: Array</*u8*/ number> }): Bytes_ {
      return new Bytes_(inner);
    }

    static instanceOf(obj: any): obj is Bytes_ {
      return obj.tag === ScalarValue_Tags.Bytes;
    }
  }

  type String__interface = {
    tag: ScalarValue_Tags.String;
    inner: Readonly<{ value: string }>;
  };

  class String_ extends UniffiEnum implements String__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.String;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super("ScalarValue", "String");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): String_ {
      return new String_(inner);
    }

    static instanceOf(obj: any): obj is String_ {
      return obj.tag === ScalarValue_Tags.String;
    }
  }

  type Uint__interface = {
    tag: ScalarValue_Tags.Uint;
    inner: Readonly<{ value: /*u64*/ bigint }>;
  };

  class Uint_ extends UniffiEnum implements Uint__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Uint;
    readonly inner: Readonly<{ value: /*u64*/ bigint }>;
    constructor(inner: { value: /*u64*/ bigint }) {
      super("ScalarValue", "Uint");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*u64*/ bigint }): Uint_ {
      return new Uint_(inner);
    }

    static instanceOf(obj: any): obj is Uint_ {
      return obj.tag === ScalarValue_Tags.Uint;
    }
  }

  type Int__interface = {
    tag: ScalarValue_Tags.Int;
    inner: Readonly<{ value: /*i64*/ bigint }>;
  };

  class Int_ extends UniffiEnum implements Int__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Int;
    readonly inner: Readonly<{ value: /*i64*/ bigint }>;
    constructor(inner: { value: /*i64*/ bigint }) {
      super("ScalarValue", "Int");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*i64*/ bigint }): Int_ {
      return new Int_(inner);
    }

    static instanceOf(obj: any): obj is Int_ {
      return obj.tag === ScalarValue_Tags.Int;
    }
  }

  type F64__interface = {
    tag: ScalarValue_Tags.F64;
    inner: Readonly<{ value: /*f64*/ number }>;
  };

  class F64_ extends UniffiEnum implements F64__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.F64;
    readonly inner: Readonly<{ value: /*f64*/ number }>;
    constructor(inner: { value: /*f64*/ number }) {
      super("ScalarValue", "F64");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*f64*/ number }): F64_ {
      return new F64_(inner);
    }

    static instanceOf(obj: any): obj is F64_ {
      return obj.tag === ScalarValue_Tags.F64;
    }
  }

  type Counter__interface = {
    tag: ScalarValue_Tags.Counter;
    inner: Readonly<{ value: /*i64*/ bigint }>;
  };

  class Counter_ extends UniffiEnum implements Counter__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Counter;
    readonly inner: Readonly<{ value: /*i64*/ bigint }>;
    constructor(inner: { value: /*i64*/ bigint }) {
      super("ScalarValue", "Counter");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*i64*/ bigint }): Counter_ {
      return new Counter_(inner);
    }

    static instanceOf(obj: any): obj is Counter_ {
      return obj.tag === ScalarValue_Tags.Counter;
    }
  }

  type Timestamp__interface = {
    tag: ScalarValue_Tags.Timestamp;
    inner: Readonly<{ value: /*i64*/ bigint }>;
  };

  class Timestamp_ extends UniffiEnum implements Timestamp__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Timestamp;
    readonly inner: Readonly<{ value: /*i64*/ bigint }>;
    constructor(inner: { value: /*i64*/ bigint }) {
      super("ScalarValue", "Timestamp");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*i64*/ bigint }): Timestamp_ {
      return new Timestamp_(inner);
    }

    static instanceOf(obj: any): obj is Timestamp_ {
      return obj.tag === ScalarValue_Tags.Timestamp;
    }
  }

  type Boolean__interface = {
    tag: ScalarValue_Tags.Boolean;
    inner: Readonly<{ value: boolean }>;
  };

  class Boolean_ extends UniffiEnum implements Boolean__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Boolean;
    readonly inner: Readonly<{ value: boolean }>;
    constructor(inner: { value: boolean }) {
      super("ScalarValue", "Boolean");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: boolean }): Boolean_ {
      return new Boolean_(inner);
    }

    static instanceOf(obj: any): obj is Boolean_ {
      return obj.tag === ScalarValue_Tags.Boolean;
    }
  }

  type Unknown__interface = {
    tag: ScalarValue_Tags.Unknown;
    inner: Readonly<{ typeCode: /*u8*/ number; data: Array</*u8*/ number> }>;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Unknown;
    readonly inner: Readonly<{
      typeCode: /*u8*/ number;
      data: Array</*u8*/ number>;
    }>;
    constructor(inner: {
      typeCode: /*u8*/ number;
      data: Array</*u8*/ number>;
    }) {
      super("ScalarValue", "Unknown");
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      typeCode: /*u8*/ number;
      data: Array</*u8*/ number>;
    }): Unknown_ {
      return new Unknown_(inner);
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === ScalarValue_Tags.Unknown;
    }
  }

  type Null__interface = {
    tag: ScalarValue_Tags.Null;
  };

  class Null_ extends UniffiEnum implements Null__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "ScalarValue";
    readonly tag = ScalarValue_Tags.Null;
    constructor() {
      super("ScalarValue", "Null");
    }

    static new(): Null_ {
      return new Null_();
    }

    static instanceOf(obj: any): obj is Null_ {
      return obj.tag === ScalarValue_Tags.Null;
    }
  }

  function instanceOf(obj: any): obj is ScalarValue {
    return obj[uniffiTypeNameSymbol] === "ScalarValue";
  }

  return Object.freeze({
    instanceOf,
    Bytes: Bytes_,
    String: String_,
    Uint: Uint_,
    Int: Int_,
    F64: F64_,
    Counter: Counter_,
    Timestamp: Timestamp_,
    Boolean: Boolean_,
    Unknown: Unknown_,
    Null: Null_,
  });
})();

export type ScalarValue = InstanceType<
  (typeof ScalarValue)[keyof Omit<typeof ScalarValue, "instanceOf">]
>;

// FfiConverter for enum ScalarValue
const FfiConverterTypeScalarValue = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ScalarValue;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ScalarValue.Bytes({
            value: FfiConverterArrayUInt8.read(from),
          });
        case 2:
          return new ScalarValue.String({
            value: FfiConverterString.read(from),
          });
        case 3:
          return new ScalarValue.Uint({ value: FfiConverterUInt64.read(from) });
        case 4:
          return new ScalarValue.Int({ value: FfiConverterInt64.read(from) });
        case 5:
          return new ScalarValue.F64({ value: FfiConverterFloat64.read(from) });
        case 6:
          return new ScalarValue.Counter({
            value: FfiConverterInt64.read(from),
          });
        case 7:
          return new ScalarValue.Timestamp({
            value: FfiConverterInt64.read(from),
          });
        case 8:
          return new ScalarValue.Boolean({
            value: FfiConverterBool.read(from),
          });
        case 9:
          return new ScalarValue.Unknown({
            typeCode: FfiConverterUInt8.read(from),
            data: FfiConverterArrayUInt8.read(from),
          });
        case 10:
          return new ScalarValue.Null();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ScalarValue_Tags.Bytes: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayUInt8.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.String: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.Uint: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.Int: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterInt64.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.F64: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.Counter: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterInt64.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.Timestamp: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterInt64.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.Boolean: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.value, into);
          return;
        }
        case ScalarValue_Tags.Unknown: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterUInt8.write(inner.typeCode, into);
          FfiConverterArrayUInt8.write(inner.data, into);
          return;
        }
        case ScalarValue_Tags.Null: {
          ordinalConverter.write(10, into);
          return;
        }
        default:
          // Throwing from here means that ScalarValue_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ScalarValue_Tags.Bytes: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayUInt8.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.String: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.Uint: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterUInt64.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.Int: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterInt64.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.F64: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterFloat64.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.Counter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterInt64.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.Timestamp: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterInt64.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.Boolean: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterBool.allocationSize(inner.value);
          return size;
        }
        case ScalarValue_Tags.Unknown: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterUInt8.allocationSize(inner.typeCode);
          size += FfiConverterArrayUInt8.allocationSize(inner.data);
          return size;
        }
        case ScalarValue_Tags.Null: {
          return ordinalConverter.allocationSize(10);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum TextEncoding {
  UnicodeCodePoint,
  Utf8CodeUnit,
  Utf16CodeUnit,
  GraphemeCluster,
}

const FfiConverterTypeTextEncoding = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TextEncoding;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return TextEncoding.UnicodeCodePoint;
        case 2:
          return TextEncoding.Utf8CodeUnit;
        case 3:
          return TextEncoding.Utf16CodeUnit;
        case 4:
          return TextEncoding.GraphemeCluster;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case TextEncoding.UnicodeCodePoint:
          return ordinalConverter.write(1, into);
        case TextEncoding.Utf8CodeUnit:
          return ordinalConverter.write(2, into);
        case TextEncoding.Utf16CodeUnit:
          return ordinalConverter.write(3, into);
        case TextEncoding.GraphemeCluster:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: Value
export enum Value_Tags {
  Object = "Object",
  Scalar = "Scalar",
}
export const Value = (() => {
  type Object__interface = {
    tag: Value_Tags.Object;
    inner: Readonly<{ typ: ObjType; id: ObjId }>;
  };

  class Object_ extends UniffiEnum implements Object__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "Value";
    readonly tag = Value_Tags.Object;
    readonly inner: Readonly<{ typ: ObjType; id: ObjId }>;
    constructor(inner: { typ: ObjType; id: ObjId }) {
      super("Value", "Object");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { typ: ObjType; id: ObjId }): Object_ {
      return new Object_(inner);
    }

    static instanceOf(obj: any): obj is Object_ {
      return obj.tag === Value_Tags.Object;
    }
  }

  type Scalar__interface = {
    tag: Value_Tags.Scalar;
    inner: Readonly<{ value: ScalarValue }>;
  };

  class Scalar_ extends UniffiEnum implements Scalar__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = "Value";
    readonly tag = Value_Tags.Scalar;
    readonly inner: Readonly<{ value: ScalarValue }>;
    constructor(inner: { value: ScalarValue }) {
      super("Value", "Scalar");
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: ScalarValue }): Scalar_ {
      return new Scalar_(inner);
    }

    static instanceOf(obj: any): obj is Scalar_ {
      return obj.tag === Value_Tags.Scalar;
    }
  }

  function instanceOf(obj: any): obj is Value {
    return obj[uniffiTypeNameSymbol] === "Value";
  }

  return Object.freeze({
    instanceOf,
    Object: Object_,
    Scalar: Scalar_,
  });
})();

export type Value = InstanceType<
  (typeof Value)[keyof Omit<typeof Value, "instanceOf">]
>;

// FfiConverter for enum Value
const FfiConverterTypeValue = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Value;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Value.Object({
            typ: FfiConverterTypeObjType.read(from),
            id: FfiConverterTypeObjId.read(from),
          });
        case 2:
          return new Value.Scalar({
            value: FfiConverterTypeScalarValue.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Value_Tags.Object: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeObjType.write(inner.typ, into);
          FfiConverterTypeObjId.write(inner.id, into);
          return;
        }
        case Value_Tags.Scalar: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeScalarValue.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that Value_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Value_Tags.Object: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeObjType.allocationSize(inner.typ);
          size += FfiConverterTypeObjId.allocationSize(inner.id);
          return size;
        }
        case Value_Tags.Scalar: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeScalarValue.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export interface DocInterface {
  actorId(): ActorId;
  applyEncodedChanges(changes: Array</*u8*/ number>) /*throws*/ : void;
  applyEncodedChangesWithPatches(
    changes: Array</*u8*/ number>,
  ) /*throws*/ : Array<Patch>;
  changeByHash(hash: ChangeHash): Change | undefined;
  changes(): Array<ChangeHash>;
  commitWith(msg: string | undefined, time: /*i64*/ bigint): void;
  cursor(obj: ObjId, position: /*u64*/ bigint) /*throws*/ : Cursor;
  cursorAt(
    obj: ObjId,
    position: /*u64*/ bigint,
    heads: Array<ChangeHash>,
  ) /*throws*/ : Cursor;
  cursorPosition(obj: ObjId, cursor: Cursor) /*throws*/ : /*u64*/ bigint;
  cursorPositionAt(
    obj: ObjId,
    cursor: Cursor,
    heads: Array<ChangeHash>,
  ) /*throws*/ : /*u64*/ bigint;
  deleteInList(obj: ObjId, index: /*u64*/ bigint) /*throws*/ : void;
  deleteInMap(obj: ObjId, key: string) /*throws*/ : void;
  difference(before: Array<ChangeHash>, after: Array<ChangeHash>): Array<Patch>;
  encodeChangesSince(
    heads: Array<ChangeHash>,
  ) /*throws*/ : Array</*u8*/ number>;
  encodeNewChanges(): Array</*u8*/ number>;
  fork(): DocInterface;
  forkAt(heads: Array<ChangeHash>) /*throws*/ : DocInterface;
  generateSyncMessage(
    state: SyncStateInterface,
  ): Array</*u8*/ number> | undefined;
  getAllAtInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    heads: Array<ChangeHash>,
  ) /*throws*/ : Array<Value>;
  getAllAtInMap(
    obj: ObjId,
    key: string,
    heads: Array<ChangeHash>,
  ) /*throws*/ : Array<Value>;
  getAllInList(obj: ObjId, index: /*u64*/ bigint) /*throws*/ : Array<Value>;
  getAllInMap(obj: ObjId, key: string) /*throws*/ : Array<Value>;
  getAtInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    heads: Array<ChangeHash>,
  ) /*throws*/ : Value | undefined;
  getAtInMap(
    obj: ObjId,
    key: string,
    heads: Array<ChangeHash>,
  ) /*throws*/ : Value | undefined;
  getInList(obj: ObjId, index: /*u64*/ bigint) /*throws*/ : Value | undefined;
  getInMap(obj: ObjId, key: string) /*throws*/ : Value | undefined;
  heads(): Array<ChangeHash>;
  incrementInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    by: /*i64*/ bigint,
  ) /*throws*/ : void;
  incrementInMap(obj: ObjId, key: string, by: /*i64*/ bigint) /*throws*/ : void;
  insertInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    value: ScalarValue,
  ) /*throws*/ : void;
  insertObjectInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    objType: ObjType,
  ) /*throws*/ : ObjId;
  joinBlock(obj: ObjId, index: /*u32*/ number) /*throws*/ : void;
  length(obj: ObjId): /*u64*/ bigint;
  lengthAt(obj: ObjId, heads: Array<ChangeHash>): /*u64*/ bigint;
  mapEntries(obj: ObjId) /*throws*/ : Array<KeyValue>;
  mapEntriesAt(
    obj: ObjId,
    heads: Array<ChangeHash>,
  ) /*throws*/ : Array<KeyValue>;
  mapKeys(obj: ObjId): Array<string>;
  mapKeysAt(obj: ObjId, heads: Array<ChangeHash>): Array<string>;
  mark(
    obj: ObjId,
    start: /*u64*/ bigint,
    end: /*u64*/ bigint,
    expand: ExpandMark,
    name: string,
    value: ScalarValue,
  ) /*throws*/ : void;
  marks(obj: ObjId) /*throws*/ : Array<Mark>;
  marksAt(obj: ObjId, heads: Array<ChangeHash>) /*throws*/ : Array<Mark>;
  marksAtPosition(
    obj: ObjId,
    position: Position,
    heads: Array<ChangeHash>,
  ) /*throws*/ : Array<Mark>;
  merge(other: DocInterface) /*throws*/ : void;
  mergeWithPatches(other: DocInterface) /*throws*/ : Array<Patch>;
  objectType(obj: ObjId): ObjType;
  path(obj: ObjId) /*throws*/ : Array<PathElement>;
  putInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    value: ScalarValue,
  ) /*throws*/ : void;
  putInMap(obj: ObjId, key: string, value: ScalarValue) /*throws*/ : void;
  putObjectInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    objType: ObjType,
  ) /*throws*/ : ObjId;
  putObjectInMap(obj: ObjId, key: string, objType: ObjType) /*throws*/ : ObjId;
  receiveSyncMessage(
    state: SyncStateInterface,
    msg: Array</*u8*/ number>,
  ) /*throws*/ : void;
  receiveSyncMessageWithPatches(
    state: SyncStateInterface,
    msg: Array</*u8*/ number>,
  ) /*throws*/ : Array<Patch>;
  save(): Array</*u8*/ number>;
  setActor(actor: ActorId): void;
  splice(
    obj: ObjId,
    start: /*u64*/ bigint,
    delete_: /*i64*/ bigint,
    values: Array<ScalarValue>,
  ) /*throws*/ : void;
  spliceText(
    obj: ObjId,
    start: /*u64*/ bigint,
    delete_: /*i64*/ bigint,
    chars: string,
  ) /*throws*/ : void;
  splitBlock(obj: ObjId, index: /*u32*/ number) /*throws*/ : ObjId;
  text(obj: ObjId) /*throws*/ : string;
  textAt(obj: ObjId, heads: Array<ChangeHash>) /*throws*/ : string;
  textEncoding(): TextEncoding;
  updateText(obj: ObjId, chars: string) /*throws*/ : void;
  values(obj: ObjId) /*throws*/ : Array<Value>;
  valuesAt(obj: ObjId, heads: Array<ChangeHash>) /*throws*/ : Array<Value>;
}

export class Doc extends UniffiAbstractObject implements DocInterface {
  readonly [uniffiTypeNameSymbol] = "Doc";
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_uniffi_automerge_fn_constructor_doc_new(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeDocObjectFactory.bless(pointer);
  }

  public static load(bytes: Array</*u8*/ number>): DocInterface /*throws*/ {
    return FfiConverterTypeDoc.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoadError.lift.bind(
          FfiConverterTypeLoadError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_constructor_doc_load(
            FfiConverterArrayUInt8.lower(bytes),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public static newWithActor(actor: ActorId): DocInterface {
    return FfiConverterTypeDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_constructor_doc_new_with_actor(
            FfiConverterTypeActorId.lower(actor),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public static newWithTextEncoding(textEncoding: TextEncoding): DocInterface {
    return FfiConverterTypeDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_constructor_doc_new_with_text_encoding(
            FfiConverterTypeTextEncoding.lower(textEncoding),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public actorId(): ActorId {
    return FfiConverterTypeActorId.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_actor_id(
            uniffiTypeDocObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public applyEncodedChanges(changes: Array</*u8*/ number>): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_apply_encoded_changes(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterArrayUInt8.lower(changes),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public applyEncodedChangesWithPatches(
    changes: Array</*u8*/ number>,
  ): Array<Patch> /*throws*/ {
    return FfiConverterArrayTypePatch.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_apply_encoded_changes_with_patches(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterArrayUInt8.lower(changes),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public changeByHash(hash: ChangeHash): Change | undefined {
    return FfiConverterOptionalTypeChange.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_change_by_hash(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeChangeHash.lower(hash),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public changes(): Array<ChangeHash> {
    return FfiConverterArrayTypeChangeHash.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_changes(
            uniffiTypeDocObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public commitWith(msg: string | undefined, time: /*i64*/ bigint): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_commit_with(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterOptionalString.lower(msg),
          FfiConverterInt64.lower(time),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public cursor(obj: ObjId, position: /*u64*/ bigint): Cursor /*throws*/ {
    return FfiConverterTypeCursor.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_cursor(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(position),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public cursorAt(
    obj: ObjId,
    position: /*u64*/ bigint,
    heads: Array<ChangeHash>,
  ): Cursor /*throws*/ {
    return FfiConverterTypeCursor.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_cursor_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(position),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public cursorPosition(obj: ObjId, cursor: Cursor): /*u64*/ bigint /*throws*/ {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_cursor_position(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterTypeCursor.lower(cursor),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public cursorPositionAt(
    obj: ObjId,
    cursor: Cursor,
    heads: Array<ChangeHash>,
  ): /*u64*/ bigint /*throws*/ {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_cursor_position_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterTypeCursor.lower(cursor),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public deleteInList(obj: ObjId, index: /*u64*/ bigint): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_delete_in_list(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt64.lower(index),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public deleteInMap(obj: ObjId, key: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_delete_in_map(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterString.lower(key),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public difference(
    before: Array<ChangeHash>,
    after: Array<ChangeHash>,
  ): Array<Patch> {
    return FfiConverterArrayTypePatch.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_difference(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterArrayTypeChangeHash.lower(before),
            FfiConverterArrayTypeChangeHash.lower(after),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public encodeChangesSince(
    heads: Array<ChangeHash>,
  ): Array</*u8*/ number> /*throws*/ {
    return FfiConverterArrayUInt8.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_encode_changes_since(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public encodeNewChanges(): Array</*u8*/ number> {
    return FfiConverterArrayUInt8.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_encode_new_changes(
            uniffiTypeDocObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public fork(): DocInterface {
    return FfiConverterTypeDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_fork(
            uniffiTypeDocObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public forkAt(heads: Array<ChangeHash>): DocInterface /*throws*/ {
    return FfiConverterTypeDoc.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_fork_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public generateSyncMessage(
    state: SyncStateInterface,
  ): Array</*u8*/ number> | undefined {
    return FfiConverterOptionalArrayUInt8.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_generate_sync_message(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeSyncState.lower(state),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getAllAtInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    heads: Array<ChangeHash>,
  ): Array<Value> /*throws*/ {
    return FfiConverterArrayTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_all_at_in_list(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(index),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getAllAtInMap(
    obj: ObjId,
    key: string,
    heads: Array<ChangeHash>,
  ): Array<Value> /*throws*/ {
    return FfiConverterArrayTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_all_at_in_map(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterString.lower(key),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getAllInList(
    obj: ObjId,
    index: /*u64*/ bigint,
  ): Array<Value> /*throws*/ {
    return FfiConverterArrayTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_all_in_list(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(index),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getAllInMap(obj: ObjId, key: string): Array<Value> /*throws*/ {
    return FfiConverterArrayTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_all_in_map(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterString.lower(key),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getAtInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    heads: Array<ChangeHash>,
  ): Value | undefined /*throws*/ {
    return FfiConverterOptionalTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_at_in_list(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(index),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getAtInMap(
    obj: ObjId,
    key: string,
    heads: Array<ChangeHash>,
  ): Value | undefined /*throws*/ {
    return FfiConverterOptionalTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_at_in_map(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterString.lower(key),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getInList(
    obj: ObjId,
    index: /*u64*/ bigint,
  ): Value | undefined /*throws*/ {
    return FfiConverterOptionalTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_in_list(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(index),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public getInMap(obj: ObjId, key: string): Value | undefined /*throws*/ {
    return FfiConverterOptionalTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_get_in_map(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterString.lower(key),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public heads(): Array<ChangeHash> {
    return FfiConverterArrayTypeChangeHash.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_heads(
            uniffiTypeDocObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public incrementInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    by: /*i64*/ bigint,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_increment_in_list(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt64.lower(index),
          FfiConverterInt64.lower(by),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public incrementInMap(
    obj: ObjId,
    key: string,
    by: /*i64*/ bigint,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_increment_in_map(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterString.lower(key),
          FfiConverterInt64.lower(by),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public insertInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    value: ScalarValue,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_insert_in_list(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt64.lower(index),
          FfiConverterTypeScalarValue.lower(value),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public insertObjectInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    objType: ObjType,
  ): ObjId /*throws*/ {
    return FfiConverterTypeObjId.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_insert_object_in_list(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(index),
            FfiConverterTypeObjType.lower(objType),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public joinBlock(obj: ObjId, index: /*u32*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_join_block(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt32.lower(index),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public length(obj: ObjId): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_length(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public lengthAt(obj: ObjId, heads: Array<ChangeHash>): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_length_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public mapEntries(obj: ObjId): Array<KeyValue> /*throws*/ {
    return FfiConverterArrayTypeKeyValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_map_entries(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public mapEntriesAt(
    obj: ObjId,
    heads: Array<ChangeHash>,
  ): Array<KeyValue> /*throws*/ {
    return FfiConverterArrayTypeKeyValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_map_entries_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public mapKeys(obj: ObjId): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_map_keys(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public mapKeysAt(obj: ObjId, heads: Array<ChangeHash>): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_map_keys_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public mark(
    obj: ObjId,
    start: /*u64*/ bigint,
    end: /*u64*/ bigint,
    expand: ExpandMark,
    name: string,
    value: ScalarValue,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_mark(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt64.lower(start),
          FfiConverterUInt64.lower(end),
          FfiConverterTypeExpandMark.lower(expand),
          FfiConverterString.lower(name),
          FfiConverterTypeScalarValue.lower(value),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public marks(obj: ObjId): Array<Mark> /*throws*/ {
    return FfiConverterArrayTypeMark.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_marks(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public marksAt(obj: ObjId, heads: Array<ChangeHash>): Array<Mark> /*throws*/ {
    return FfiConverterArrayTypeMark.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_marks_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public marksAtPosition(
    obj: ObjId,
    position: Position,
    heads: Array<ChangeHash>,
  ): Array<Mark> /*throws*/ {
    return FfiConverterArrayTypeMark.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_marks_at_position(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterTypePosition.lower(position),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public merge(other: DocInterface): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_merge(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeDoc.lower(other),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public mergeWithPatches(other: DocInterface): Array<Patch> /*throws*/ {
    return FfiConverterArrayTypePatch.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_merge_with_patches(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeDoc.lower(other),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public objectType(obj: ObjId): ObjType {
    return FfiConverterTypeObjType.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_object_type(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public path(obj: ObjId): Array<PathElement> /*throws*/ {
    return FfiConverterArrayTypePathElement.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_path(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public putInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    value: ScalarValue,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_put_in_list(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt64.lower(index),
          FfiConverterTypeScalarValue.lower(value),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public putInMap(
    obj: ObjId,
    key: string,
    value: ScalarValue,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_put_in_map(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterString.lower(key),
          FfiConverterTypeScalarValue.lower(value),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public putObjectInList(
    obj: ObjId,
    index: /*u64*/ bigint,
    objType: ObjType,
  ): ObjId /*throws*/ {
    return FfiConverterTypeObjId.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_put_object_in_list(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt64.lower(index),
            FfiConverterTypeObjType.lower(objType),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public putObjectInMap(
    obj: ObjId,
    key: string,
    objType: ObjType,
  ): ObjId /*throws*/ {
    return FfiConverterTypeObjId.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_put_object_in_map(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterString.lower(key),
            FfiConverterTypeObjType.lower(objType),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public receiveSyncMessage(
    state: SyncStateInterface,
    msg: Array</*u8*/ number>,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeReceiveSyncError.lift.bind(
        FfiConverterTypeReceiveSyncError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_receive_sync_message(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeSyncState.lower(state),
          FfiConverterArrayUInt8.lower(msg),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public receiveSyncMessageWithPatches(
    state: SyncStateInterface,
    msg: Array</*u8*/ number>,
  ): Array<Patch> /*throws*/ {
    return FfiConverterArrayTypePatch.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeReceiveSyncError.lift.bind(
          FfiConverterTypeReceiveSyncError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_receive_sync_message_with_patches(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeSyncState.lower(state),
            FfiConverterArrayUInt8.lower(msg),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public save(): Array</*u8*/ number> {
    return FfiConverterArrayUInt8.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_save(
            uniffiTypeDocObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public setActor(actor: ActorId): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_set_actor(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeActorId.lower(actor),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public splice(
    obj: ObjId,
    start: /*u64*/ bigint,
    delete_: /*i64*/ bigint,
    values: Array<ScalarValue>,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_splice(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt64.lower(start),
          FfiConverterInt64.lower(delete_),
          FfiConverterArrayTypeScalarValue.lower(values),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public spliceText(
    obj: ObjId,
    start: /*u64*/ bigint,
    delete_: /*i64*/ bigint,
    chars: string,
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_splice_text(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterUInt64.lower(start),
          FfiConverterInt64.lower(delete_),
          FfiConverterString.lower(chars),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public splitBlock(obj: ObjId, index: /*u32*/ number): ObjId /*throws*/ {
    return FfiConverterTypeObjId.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_split_block(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterUInt32.lower(index),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public text(obj: ObjId): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_text(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public textAt(obj: ObjId, heads: Array<ChangeHash>): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_text_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public textEncoding(): TextEncoding {
    return FfiConverterTypeTextEncoding.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_text_encoding(
            uniffiTypeDocObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public updateText(obj: ObjId, chars: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeDocError.lift.bind(
        FfiConverterTypeDocError,
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_update_text(
          uniffiTypeDocObjectFactory.clonePointer(this),
          FfiConverterTypeObjId.lower(obj),
          FfiConverterString.lower(chars),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public values(obj: ObjId): Array<Value> /*throws*/ {
    return FfiConverterArrayTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_values(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public valuesAt(
    obj: ObjId,
    heads: Array<ChangeHash>,
  ): Array<Value> /*throws*/ {
    return FfiConverterArrayTypeValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDocError.lift.bind(
          FfiConverterTypeDocError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_doc_values_at(
            uniffiTypeDocObjectFactory.clonePointer(this),
            FfiConverterTypeObjId.lower(obj),
            FfiConverterArrayTypeChangeHash.lower(heads),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeDocObjectFactory.pointer(this);
      uniffiTypeDocObjectFactory.freePointer(pointer);
      uniffiTypeDocObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Doc {
    return uniffiTypeDocObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeDocObjectFactory: UniffiObjectFactory<DocInterface> = (() => {
  return {
    create(pointer: UnsafeMutableRawPointer): DocInterface {
      const instance = Object.create(Doc.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = "Doc";
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_doc_ffi__bless_pointer(
            p,
            status,
          ),
        /*liftString:*/ FfiConverterString.lift,
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: DocInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: DocInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_uniffi_automerge_fn_clone_doc(
            pointer,
            callStatus,
          ),
        /*liftString:*/ FfiConverterString.lift,
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_uniffi_automerge_fn_free_doc(
            pointer,
            callStatus,
          ),
        /*liftString:*/ FfiConverterString.lift,
      );
    },

    isConcreteType(obj: any): obj is DocInterface {
      return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === "Doc";
    },
  };
})();
// FfiConverter for DocInterface
const FfiConverterTypeDoc = new FfiConverterObject(uniffiTypeDocObjectFactory);

export interface SyncStateInterface {
  encode(): Array</*u8*/ number>;
  reset(): void;
  theirHeads(): Array<ChangeHash> | undefined;
}

export class SyncState
  extends UniffiAbstractObject
  implements SyncStateInterface
{
  readonly [uniffiTypeNameSymbol] = "SyncState";
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_uniffi_automerge_fn_constructor_syncstate_new(
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSyncStateObjectFactory.bless(pointer);
  }

  public static decode(
    bytes: Array</*u8*/ number>,
  ): SyncStateInterface /*throws*/ {
    return FfiConverterTypeSyncState.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeDecodeSyncStateError.lift.bind(
          FfiConverterTypeDecodeSyncStateError,
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_constructor_syncstate_decode(
            FfiConverterArrayUInt8.lower(bytes),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public encode(): Array</*u8*/ number> {
    return FfiConverterArrayUInt8.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_syncstate_encode(
            uniffiTypeSyncStateObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  public reset(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_syncstate_reset(
          uniffiTypeSyncStateObjectFactory.clonePointer(this),
          callStatus,
        );
      },
      /*liftString:*/ FfiConverterString.lift,
    );
  }

  public theirHeads(): Array<ChangeHash> | undefined {
    return FfiConverterOptionalArrayTypeChangeHash.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_uniffi_automerge_fn_method_syncstate_their_heads(
            uniffiTypeSyncStateObjectFactory.clonePointer(this),
            callStatus,
          );
        },
        /*liftString:*/ FfiConverterString.lift,
      ),
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSyncStateObjectFactory.pointer(this);
      uniffiTypeSyncStateObjectFactory.freePointer(pointer);
      uniffiTypeSyncStateObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SyncState {
    return uniffiTypeSyncStateObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSyncStateObjectFactory: UniffiObjectFactory<SyncStateInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): SyncStateInterface {
        const instance = Object.create(SyncState.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = "SyncState";
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_syncstate_ffi__bless_pointer(
              p,
              status,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: SyncStateInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: SyncStateInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_uniffi_automerge_fn_clone_syncstate(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_uniffi_automerge_fn_free_syncstate(
              pointer,
              callStatus,
            ),
          /*liftString:*/ FfiConverterString.lift,
        );
      },

      isConcreteType(obj: any): obj is SyncStateInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === "SyncState"
        );
      },
    };
  })();
// FfiConverter for SyncStateInterface
const FfiConverterTypeSyncState = new FfiConverterObject(
  uniffiTypeSyncStateObjectFactory,
);

// FfiConverter for Change | undefined
const FfiConverterOptionalTypeChange = new FfiConverterOptional(
  FfiConverterTypeChange,
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for Array<KeyValue>
const FfiConverterArrayTypeKeyValue = new FfiConverterArray(
  FfiConverterTypeKeyValue,
);

// FfiConverter for Array<Mark>
const FfiConverterArrayTypeMark = new FfiConverterArray(FfiConverterTypeMark);

// FfiConverter for Array<Patch>
const FfiConverterArrayTypePatch = new FfiConverterArray(FfiConverterTypePatch);

// FfiConverter for Array<PathElement>
const FfiConverterArrayTypePathElement = new FfiConverterArray(
  FfiConverterTypePathElement,
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u8*/number>
const FfiConverterArrayUInt8 = new FfiConverterArray(FfiConverterUInt8);

// FfiConverter for Map<string, Value>
const FfiConverterMapStringTypeValue = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeValue,
);

// FfiConverter for Value | undefined
const FfiConverterOptionalTypeValue = new FfiConverterOptional(
  FfiConverterTypeValue,
);

// FfiConverter for Array</*u8*/number> | undefined
const FfiConverterOptionalArrayUInt8 = new FfiConverterOptional(
  FfiConverterArrayUInt8,
);

// FfiConverter for Array<ChangeHash>
const FfiConverterArrayTypeChangeHash = new FfiConverterArray(
  FfiConverterTypeChangeHash,
);

// FfiConverter for Array<ScalarValue>
const FfiConverterArrayTypeScalarValue = new FfiConverterArray(
  FfiConverterTypeScalarValue,
);

// FfiConverter for Array<Value>
const FfiConverterArrayTypeValue = new FfiConverterArray(FfiConverterTypeValue);

// FfiConverter for Array<ChangeHash> | undefined
const FfiConverterOptionalArrayTypeChangeHash = new FfiConverterOptional(
  FfiConverterArrayTypeChangeHash,
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_uniffi_automerge_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion,
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_func_root() !== 16665
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_func_root",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_actor_id() !==
    58187
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_actor_id",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_apply_encoded_changes() !==
    57114
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_apply_encoded_changes",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_apply_encoded_changes_with_patches() !==
    63928
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_apply_encoded_changes_with_patches",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_change_by_hash() !==
    19632
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_change_by_hash",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_changes() !==
    3101
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_changes",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_commit_with() !==
    65319
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_commit_with",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_cursor() !==
    22848
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_cursor",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_cursor_at() !==
    30653
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_cursor_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_cursor_position() !==
    18995
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_cursor_position",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_cursor_position_at() !==
    61487
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_cursor_position_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_delete_in_list() !==
    16486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_delete_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_delete_in_map() !==
    18529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_delete_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_difference() !==
    24379
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_difference",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_encode_changes_since() !==
    26938
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_encode_changes_since",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_encode_new_changes() !==
    56722
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_encode_new_changes",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_fork() !==
    38250
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_fork",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_fork_at() !==
    21144
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_fork_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_generate_sync_message() !==
    33156
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_generate_sync_message",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_all_at_in_list() !==
    18128
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_all_at_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_all_at_in_map() !==
    53785
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_all_at_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_all_in_list() !==
    35779
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_all_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_all_in_map() !==
    31318
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_all_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_at_in_list() !==
    27489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_at_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_at_in_map() !==
    32752
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_at_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_in_list() !==
    56002
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_get_in_map() !==
    43266
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_get_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_heads() !==
    30757
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_heads",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_increment_in_list() !==
    59870
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_increment_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_increment_in_map() !==
    11656
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_increment_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_insert_in_list() !==
    26099
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_insert_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_insert_object_in_list() !==
    33959
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_insert_object_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_join_block() !==
    31706
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_join_block",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_length() !==
    31664
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_length",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_length_at() !==
    44190
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_length_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_map_entries() !==
    31082
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_map_entries",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_map_entries_at() !==
    38662
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_map_entries_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_map_keys() !==
    47809
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_map_keys",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_map_keys_at() !==
    30845
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_map_keys_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_mark() !==
    19547
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_mark",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_marks() !==
    30528
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_marks",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_marks_at() !==
    22826
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_marks_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_marks_at_position() !==
    20347
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_marks_at_position",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_merge() !==
    8598
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_merge",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_merge_with_patches() !==
    63992
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_merge_with_patches",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_object_type() !==
    59614
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_object_type",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_path() !==
    1582
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_path",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_put_in_list() !==
    64209
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_put_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_put_in_map() !==
    57871
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_put_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_put_object_in_list() !==
    34781
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_put_object_in_list",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_put_object_in_map() !==
    29866
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_put_object_in_map",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_receive_sync_message() !==
    17509
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_receive_sync_message",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_receive_sync_message_with_patches() !==
    42532
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_receive_sync_message_with_patches",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_save() !==
    20308
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_save",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_set_actor() !==
    57695
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_set_actor",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_splice() !==
    46357
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_splice",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_splice_text() !==
    63165
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_splice_text",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_split_block() !==
    2350
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_split_block",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_text() !==
    59542
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_text",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_text_at() !==
    53320
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_text_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_text_encoding() !==
    58521
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_text_encoding",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_update_text() !==
    21960
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_update_text",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_values() !==
    8282
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_values",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_doc_values_at() !==
    28614
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_doc_values_at",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_syncstate_encode() !==
    34911
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_syncstate_encode",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_syncstate_reset() !==
    57480
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_syncstate_reset",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_method_syncstate_their_heads() !==
    39177
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_method_syncstate_their_heads",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_constructor_doc_load() !==
    64049
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_constructor_doc_load",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_constructor_doc_new() !==
    57529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_constructor_doc_new",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_constructor_doc_new_with_actor() !==
    12514
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_constructor_doc_new_with_actor",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_constructor_doc_new_with_text_encoding() !==
    29105
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_constructor_doc_new_with_text_encoding",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_constructor_syncstate_decode() !==
    45077
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_constructor_syncstate_decode",
    );
  }
  if (
    nativeModule().ubrn_uniffi_uniffi_automerge_checksum_constructor_syncstate_new() !==
    48058
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      "uniffi_uniffi_automerge_checksum_constructor_syncstate_new",
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeActorId,
    FfiConverterTypeChange,
    FfiConverterTypeChangeHash,
    FfiConverterTypeCursor,
    FfiConverterTypeDecodeSyncStateError,
    FfiConverterTypeDoc,
    FfiConverterTypeDocError,
    FfiConverterTypeExpandMark,
    FfiConverterTypeKeyValue,
    FfiConverterTypeLoadError,
    FfiConverterTypeMark,
    FfiConverterTypeObjId,
    FfiConverterTypeObjType,
    FfiConverterTypePatch,
    FfiConverterTypePatchAction,
    FfiConverterTypePathElement,
    FfiConverterTypePosition,
    FfiConverterTypeProp,
    FfiConverterTypeReceiveSyncError,
    FfiConverterTypeScalarValue,
    FfiConverterTypeSyncState,
    FfiConverterTypeTextEncoding,
    FfiConverterTypeValue,
  },
});
